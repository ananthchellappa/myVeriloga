// VerilogA for PQ84_AC, iref_trimmer, veriloga

`include "constants.h"
`include "disciplines.h"

module iref_trimmer(B1, B2, B3, B4, B5, B6, IREF2UA, CODEby64);
output B1, B2, B3, B4, B5, B6;
input IREF2UA, CODEby64;
electrical B1, B2, B3, B4, B5, B6, IREF2UA, CODEby64;

parameter real vlogic_high = 3;
parameter real vlogic_low  = 0;

real iref_untrimmed;
real weights[1:6];
real trim[1:6];
real rcor_reqd;
real correction;
integer quotient;
integer i;

    analog begin

      @ ( initial_step ) begin
        correction = 0;
        weights[1] = 0.015625;
        weights[2] = 0.03125;
        weights[3] = 0.0625;
        weights[4] = 0.125;
        weights[5] = 0.25;
        weights[6] = -0.5;
        iref_untrimmed = V(IREF2UA);
        rcor_reqd = 1 - iref_untrimmed/2e-6;
// weights must always be arranged in descending order of absolute
// value for this to work
        if( V(CODEby64) < 0 ) begin
            for( i = 6; i > 0 ; i = i - 1) begin
                if( (correction + weights[i] ) <rcor_reqd ) begin
                    if( (weights[i]/rcor_reqd) > 0 ) begin   // checking sign here
                        trim[i] = vlogic_high;
                        correction = correction + weights[i];
                    end
                end else
                begin
                    trim[i] = vlogic_low;
                end
            end // for
        end // if V(CODEby
        else begin
            quotient = V(CODEby64) * 64.0;
            for( i = 1; i < 7 ; i = i + 1) begin
//                trim[i] = (quotient % 2)? vlogic_high : vlogic_low;
                trim[i] = (quotient & (1<<(i-1)) )? vlogic_high : vlogic_low;
            end // for
        end
            
      end   // initial step

      V(B6) <+ trim[6];
      V(B5) <+ trim[5];
      V(B4) <+ trim[4];
      V(B3) <+ trim[3];
      V(B2) <+ trim[2];
      V(B1) <+ trim[1];

    end // analog
endmodule
